# 说明

这个项目是我在阅读《图解设计模式》时使用 `C++`将书中的代码（`Java` 版本）给实现一遍，巩固 `C++` 语法的同时感受一下 `设计模式` 的魅力。

# 第一章 Iterator模式

# 第二章 Adapter模式
也称为Wrapper模式。

分类
+ 类适配器模式（使用继承的适配器）
+ 对象适配器（使用委托的适配器）

什么时候使用Adapter模式：在已经开发完成的类的基础上，将这些类的方法组合起来使用，
这时候就可以使用适配器，当出现Bug时，只需要关注Adapter角色的类即可。

使用Adapter模式可以在完全不改变现有代码的前提下使现有代码适配于新的接口（API）。

适配器可以用于版本升级中，做到版本兼容。

# 第三章 Template Method模式
Template Method模式：在父类中定义处理流程的框架，在子类中实现具体处理的模式。

# 第四章 Factory Method模式
Factory Method模式：将Template Method模式中的处理流程用来生成实例。

# 第五章 Singleton模式
Singleton模式：确保只生成一个实例。

# 第六章 Prototype模式
Prototype模式：根据现有的实例来生成新的实例。

使用场景
+ 对象种类繁多，无法将它们整合到一个类中
+ 难以根据类生成实例
+ 想解耦框架与生成的实例

# 第七章 Builder模式
Builder模式：用于组装具有复杂结构的实例。

# 第八章 Abstract Factory模式
抽象工厂的工作是将抽象零件组装成抽象产品。

抽象工厂模式易于增加新的工厂，但是不容易添加新的零件。

由于C++没有反射，我不知道如何根据类的名字动态获取工厂，所以没有在Factory中添加GetFactory函数。

# 第九章 Bridge模式
将类的功能层次结构与实现层次结构分离。

# 第十章 Strategy模式
Strategy模式：可以方便地替换算法。

# 第十一章 Composite模式
Composite模式：容器与内容的一致性。

Add方法的实现
+ 定义在Entry类中，报错
+ 定义在Entry类中，但什么都不做
+ 生命在Entry类中，但不实现
+ 只定义在Directory类中

# 第十二章 Decorator模式
装饰边框与被装饰物的一致性。

可以在不改变原有接口的情况下增加新功能。

缺点：导致程序中增加许多功能类似的很小的类。

# 第十三章 Visitor模式
访问数据结构并处理数据。

易于增加ConcreteVisitor角色，难以增加ConcreteElement角色。

# 第十四章 Chain of Responsibility模式

# 第十五章 Facade模式

# 第十六章 Mediator模式

# 第十七章 Observer模式
当观察对象的状态发生变化时，会通知给观察者。

# 第十八章 Memento模式

# 第十九章 State模式

# 第二十章 Flyweight模式
通过尽量共享实例来避免new出实例。

# 第二十一章 Proxy模式

# 第二十二章 Command模式

# 第二十三章 Interpreter模式


# 踩坑记录
1、包含头文件顺序有问题，导致报错。

2、在使用动态对象数组时，对象所属的类必须有默认构造函数。

3、在函数参数中传入数组时，必须同时传入数组的大小。

4、静态成员变量一定要在类外初始化。

5、注意数组下标是从0开始的，而我们数数是从1开始的，需要进行转换，比较容易发生数组下标越界。
报错信息 `interrupted by signal 11: sigsegv`。

6、有时会误写，如读文件将 `sizeof(line)` 写成了 `sizeof(char)`。

# 待做
1、带有指针成员变量的类，需要改写构造函数和析构函数。

2、课后练习

3、第十六章、第十九章、第二十二章由于用到了Java GUI，个人目前无法改写，留待日后实现。